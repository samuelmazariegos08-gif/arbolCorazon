<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>San Valentín</title>
  <style>
    :root {
      --bg: #f4e9df;
      --ink: #4a3c34;
      --accent: #d03c3c;
      --accent-2: #ff6b81;
      --accent-3: #ff9bb3;
      --ground: rgba(74, 60, 52, 0.45);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: #f7eee4;
      color: var(--ink);
      font-family: "Georgia", "Times New Roman", serif;
    }

    .frame {
      width: min(1200px, 92vw);
      aspect-ratio: 16 / 9;
      background: var(--bg);
      border-radius: 28px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.12);
      padding: clamp(1.2rem, 2.5vw, 2.6rem);
    }

    .layout {
      position: absolute;
      inset: clamp(1rem, 2vw, 2.2rem);
      display: grid;
      grid-template-columns: 1.45fr 0.55fr;
      gap: clamp(0.15rem, 0.6vw, 0.5rem);
      align-items: center;
    }

    .left {
      align-self: center;
      font-size: clamp(0.82rem, 1.1vw, 1rem);
      line-height: 1.7;
    }

    .type-line {
      min-height: 1.6em;
      margin: 0 0 0.8rem 0;
      white-space: pre-wrap;
    }

    .signature {
      margin-top: 0.6rem;
    }

    .counter {
      margin-top: 1.2rem;
      font-size: clamp(0.9rem, 1.3vw, 1.1rem);
    }

    .counter strong {
      display: block;
      font-weight: 600;
      margin-bottom: 0.2rem;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    @media (max-width: 900px) {
      .frame {
        aspect-ratio: auto;
        min-height: 86vh;
      }

      .layout {
        position: relative;
        inset: 0;
        height: 100%;
        grid-template-columns: 1fr;
        grid-template-rows: 52vh auto;
        gap: 0.8rem;
      }

      canvas {
        height: 52vh;
      }

      .left {
        order: 2;
        font-size: 0.98rem;
      }
    }

    @media (max-width: 640px) {
      .frame {
        min-height: 92vh;
        padding: 0.9rem;
      }

      .layout {
        grid-template-rows: 50vh auto;
      }

      .left {
        font-size: 0.95rem;
      }
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="layout">
      <div class="left">
        <div class="type-line" id="title"></div>
        <div class="type-line" id="body"></div>
        <div class="type-line signature" id="signature"></div>
        <div class="counter" id="counter-wrap">
          <strong>Mi amor por ti comenzó hace…</strong>
          <div id="counter"></div>
        </div>
      </div>
      <canvas id="scene"></canvas>
    </div>
  </div>

  <script>
    // ====== EDITA AQUÍ ======
    const CONFIG = {
      startDate: "2024-01-01T00:00:00",
      title: "Para el amor de mi vida:",
      body: "Si pudiera elegir un lugar \nseguro, sería a tu lado.\n\nCuanto mas tiempo estoy \ncontigo más te amo.",
      signature: "-- I Love You!",
      treeX: 0.65, // posición horizontal del árbol (0 a 1)
      groundY: 0.86, // altura del suelo (0 a 1)
    };

    // ====== COPA (ajusta aquí) ======
    const CROWN_DENSITY = 1.35; // 1.0 = normal, 1.6 = súper tupido
    const CROWN_RADIUS_FACTOR = 0.23; // +15% tamaño base de copa
    const JITTER_RANGE = 1.2; // menos = menos huecos
    const HEART_SIZE_MIN = 10.53; // +50%
    const HEART_SIZE_MAX = 20.48; // +50%
    const FILL_ALPHA = 0.92;
    const HEART_COLORS = [
      { h: 350, s: 92, l: [55, 65] }, // rojo
      { h: 340, s: 90, l: [58, 70] }, // fucsia
      { h: 330, s: 85, l: [60, 72] }, // rosa
      { h: 340, s: 65, l: [78, 88] }, // rosa pálido
      { h: 358, s: 90, l: [52, 62] }, // rojo profundo
    ];

    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    const state = {
      w: 0,
      h: 0,
      leaves: [],
      falling: [],
      startTime: new Date(CONFIG.startDate),
      animStart: 0,
      phaseStart: 0,
      started: false,
      dot: { x: 0, y: 0, vy: 0, bounces: 0, active: false },
      treeGrow: 0,
      branchGrow: 0,
      leavesGrow: 0,
    };

    function resize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * devicePixelRatio);
      canvas.height = Math.floor(rect.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      state.w = rect.width;
      state.h = rect.height;
    }

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function heartPoint(t) {
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      return { x, y: -y };
    }

    function buildCrown() {
      const crownHearts = [];
      const palette = HEART_COLORS;
      const areaFactor = Math.max(0.9, Math.min(1.6, (state.w * state.h) / (820 * 460)));
      const outlineCount = Math.floor(2600 * CROWN_DENSITY * areaFactor);
      const fillCount = Math.floor(900 * CROWN_DENSITY * areaFactor); // 50% menos adicional
      const baseRadius = CROWN_RADIUS_FACTOR * Math.min(state.w, state.h);

      // Contorno del corazón
      for (let i = 0; i < outlineCount; i += 1) {
        const t = rand(0, Math.PI * 2);
        const p = heartPoint(t);
        const nx = p.x * baseRadius + rand(-JITTER_RANGE, JITTER_RANGE);
        const ny = p.y * baseRadius + rand(-JITTER_RANGE, JITTER_RANGE);
        const tone = palette[Math.floor(rand(0, palette.length))];
        const light = rand(tone.l[0], tone.l[1]);
        crownHearts.push({
          x: nx,
          y: ny,
          size: rand(HEART_SIZE_MIN, HEART_SIZE_MAX),
          hue: tone.h,
          sat: tone.s,
          light,
          alpha: rand(0.8, 1),
        });
      }

      // Relleno interno (evita huecos) usando muestreo dentro del corazón
      let tries = 0;
      let added = 0;
      while (added < fillCount && tries < fillCount * 8) {
        tries += 1;
        const x = rand(-1.2, 1.2);
        const y = rand(-1.2, 1.2);
        const heartEq = Math.pow(x * x + y * y - 1, 3) - x * x * y * y * y;
        if (heartEq <= 0) {
          const nx = x * baseRadius + rand(-JITTER_RANGE, JITTER_RANGE);
          const ny = -y * baseRadius + rand(-JITTER_RANGE, JITTER_RANGE);
          const tone = palette[Math.floor(rand(0, palette.length))];
          const light = rand(tone.l[0], tone.l[1]);
          crownHearts.push({
            x: nx,
            y: ny,
            size: rand(HEART_SIZE_MIN, HEART_SIZE_MAX) * rand(0.9, 1.2),
            hue: tone.h,
            sat: tone.s,
            light,
            alpha: rand(FILL_ALPHA, 0.98),
          });
          added += 1;
        }
      }

      return crownHearts;
    }

    function initLeaves() {
      state.leaves = buildCrown();
    }

    function drawHeart(x, y, size, color, alpha, rotation = 0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.scale(size, size);
      ctx.beginPath();
      ctx.moveTo(0, -2.5);
      ctx.bezierCurveTo(2.4, -5.2, 6, -2.2, 0, 4.4);
      ctx.bezierCurveTo(-6, -2.2, -2.4, -5.2, 0, -2.5);
      ctx.closePath();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }

    function drawLeaves(centerX, centerY, progress) {
      const visible = Math.floor(state.leaves.length * progress);
      for (let i = 0; i < visible; i += 1) {
        const leaf = state.leaves[i];
        const color = `hsla(${leaf.hue}, ${leaf.sat}%, ${leaf.light}%, ${leaf.alpha})`;
        drawHeart(centerX + leaf.x, centerY + leaf.y, leaf.size * 0.085, color, leaf.alpha);
      }
    }

    function spawnFalling() {
      if (state.falling.length > 70) return;
      if (Math.random() < 0.3) {
        const leaf = state.leaves[Math.floor(rand(0, state.leaves.length))];
        state.falling.push({
          x: leaf.x + state.w * CONFIG.treeX,
          y: leaf.y + state.h * 0.32,
          size: rand(6, 12),
          vx: rand(-0.6, -0.15),
          vy: rand(0.45, 1.2),
          rot: rand(0, Math.PI * 2),
          spin: rand(-0.02, 0.02),
          alpha: rand(0.6, 0.95),
          hue: leaf.hue,
          sat: leaf.sat,
          light: leaf.light,
          bounce: 0,
        });
      }
    }

    function drawFalling(groundY) {
      state.falling.forEach((leaf) => {
        leaf.x += (leaf.vx + Math.sin(leaf.y * 0.02) * 0.2) * 1.8;
        leaf.y += leaf.vy * 1.8;
        leaf.vy += 0.018;
        leaf.rot += leaf.spin;

        if (leaf.y > groundY - 4 && leaf.bounce < 2) {
          leaf.y = groundY - 4;
          leaf.vy *= -0.4;
          leaf.vx *= 0.8;
          leaf.bounce += 1;
        }

        leaf.alpha -= 0.002;
        drawHeart(
          leaf.x,
          leaf.y,
          leaf.size * 0.08,
          `hsla(${leaf.hue}, ${leaf.sat}%, ${leaf.light}%, 1)`,
          Math.max(leaf.alpha, 0),
          leaf.rot
        );
      });
      state.falling = state.falling.filter((leaf) => leaf.y < groundY + 30 && leaf.alpha > 0);
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function drawBranch(x1, y1, x2, y2, progress, width) {
      const px = lerp(x1, x2, progress);
      const py = lerp(y1, y2, progress);
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(px, py);
      ctx.stroke();
    }

    function drawTree(baseX, baseY, trunkProgress, branchProgress, sway) {
      ctx.save();
      ctx.strokeStyle = "#8b5a2b";
      ctx.lineCap = "round";

      const trunkHeight = state.h * 0.46;
      const topY = baseY - trunkHeight * trunkProgress;
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.moveTo(baseX, baseY);
      ctx.lineTo(baseX + sway * 10, topY);
      ctx.stroke();

      drawBranch(baseX + sway * 2, baseY - trunkHeight * 0.22, baseX + 42 + sway * 10, baseY - trunkHeight * 0.44, branchProgress, 9);
      drawBranch(baseX + sway * 2, baseY - trunkHeight * 0.38, baseX - 40 + sway * 8, baseY - trunkHeight * 0.58, branchProgress, 8);
      drawBranch(baseX + sway * 3, baseY - trunkHeight * 0.56, baseX + 34 + sway * 9, baseY - trunkHeight * 0.78, branchProgress, 7);
      drawBranch(baseX + sway * 3, baseY - trunkHeight * 0.68, baseX - 32 + sway * 7, baseY - trunkHeight * 0.9, branchProgress, 6);

      drawBranch(baseX + sway * 1, baseY - trunkHeight * 0.3, baseX + 20 + sway * 6, baseY - trunkHeight * 0.5, branchProgress, 6);
      drawBranch(baseX + sway * 1, baseY - trunkHeight * 0.48, baseX - 20 + sway * 5, baseY - trunkHeight * 0.65, branchProgress, 5);
      drawBranch(baseX + sway * 2, baseY - trunkHeight * 0.62, baseX + 18 + sway * 5, baseY - trunkHeight * 0.84, branchProgress, 5);

      ctx.restore();
    }

    function updateCounter() {
      const now = new Date();
      const diff = Math.max(0, now - state.startTime);
      const totalSeconds = Math.floor(diff / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      const counter = document.getElementById("counter");
      counter.textContent = `${days} días ${String(hours).padStart(2, "0")} horas ${String(minutes).padStart(2, "0")} minutos ${String(seconds).padStart(2, "0")} segundos`;
    }

    // ====== MAQUINA DE ESCRIBIR ======
    const titleEl = document.getElementById("title");
    const bodyEl = document.getElementById("body");
    const signatureEl = document.getElementById("signature");

    function typeText(el, text, speed, callback) {
      let i = 0;
      function step() {
        el.textContent = text.slice(0, i);
        i += 1;
        if (i <= text.length) {
          setTimeout(step, speed);
        } else if (callback) {
          callback();
        }
      }
      step();
    }

    // ====== ANIMACIÓN PRINCIPAL ======
    function startAnimation() {
      state.started = true;
      state.animStart = performance.now();
      state.dot.active = true;
      state.dot.x = state.w * CONFIG.treeX;
      state.dot.y = state.h * 0.1;
      state.dot.vy = 0;
      state.dot.bounces = 0;

      typeText(titleEl, CONFIG.title, 35, () => {
        typeText(bodyEl, CONFIG.body, 20, () => {
          typeText(signatureEl, CONFIG.signature, 35);
        });
      });
    }

    function updateDot(groundY) {
      const dot = state.dot;
      if (!dot.active) return;

      dot.vy += 0.5; // gravedad
      dot.y += dot.vy;

      if (dot.y >= groundY - 6) {
        dot.y = groundY - 6;
        dot.vy *= -0.5;
        dot.bounces += 1;
        if (Math.abs(dot.vy) < 1 || dot.bounces > 4) {
          dot.active = false;
          dot.y = groundY - 6;
        }
      }

      ctx.beginPath();
      ctx.fillStyle = "#d03c3c";
      ctx.arc(dot.x, dot.y, 6, 0, Math.PI * 2);
      ctx.fill();
    }

    function render(time) {
      if (!state.started) return;
      ctx.clearRect(0, 0, state.w, state.h);

      const groundY = state.h * CONFIG.groundY;

      // suelo
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--ground");
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(state.w, groundY);
      ctx.stroke();

      updateDot(groundY);

      const t = (time - state.animStart) / 1000;

      // crecimiento del árbol
      state.treeGrow = Math.min(1, Math.max(0, (t - 1.2) / 1.2));
      state.branchGrow = Math.min(1, Math.max(0, (t - 1.6) / 1.2));
      state.leavesGrow = Math.min(1, Math.max(0, (t - 2.1) / 1.8));

      const sway = Math.sin(t * 1.1) * 0.6;
      drawTree(state.w * CONFIG.treeX, groundY, easeOutCubic(state.treeGrow), easeOutCubic(state.branchGrow), sway);
      drawLeaves(state.w * CONFIG.treeX, groundY - state.h * 0.34, easeOutCubic(state.leavesGrow));

      if (state.leavesGrow > 0.3) {
        spawnFalling();
        drawFalling(groundY);
      }

      requestAnimationFrame(render);
    }

    function init() {
      resize();
      initLeaves();
      updateCounter();
      setInterval(updateCounter, 1000);
      startAnimation();
      requestAnimationFrame(render);
    }

    window.addEventListener("resize", () => {
      resize();
      initLeaves();
    });

    init();
  </script>
</body>
</html>
